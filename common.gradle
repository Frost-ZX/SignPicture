buildscript {
	repositories {
		mavenCentral()
		jcenter()
		maven {
			name = 'forge'
			url = 'http://files.minecraftforge.net/maven'
		}
		maven {
			name = 'sonatype'
			url = 'https://oss.sonatype.org/content/repositories/snapshots/'
		}
	}

	dependencies {
		classpath project.forgegradle
	}
}

plugins {
	id 'com.github.johnrengelman.shadow' version '1.2.4'
	id 'com.matthewprenger.cursegradle' version '1.0.8'
	id 'com.palantir.git-version' version '0.7.1'
	id 'co.riiid.gradle' version '0.4.2'
}

apply plugin: project.forgegradle_plugin

version = "${project.version_minecraft}-${mod_version}"
archivesBaseName = rootProject.name

configurations {
	shade
	compile.extendsFrom shade
}

[compileJava, compileApiJava, compileTestJava]*.options*.encoding = 'UTF-8'
sourceCompatibility = targetCompatibility = '1.6'

minecraft {
	version = "${project.version_minecraft}-${project.version_forge}"

	if (project.isProperty('version_mappings'))
		mappings = project.version_mappings

	if (!project.isProperty('run_location'))
		runDir = 'run'
	else
		runDir = run_location.replace('{modid}', project.modid).replace('{mcversion}', project.version_minecraft)

	replaceIn 'Reference.java'
	replace '${modid}', project.modid
	replace '${modname}', project.modname
	replace '${version}', mod_version
	replace '${mcversion}', project.version_minecraft
	replace '${forgeversion}', project.version_forge
}

sourceSets {
    api {
        java {
            srcDir '../src/api/java'
        }
        resources {
            srcDir '../src/api/resources'
        }
    }
    main {
        java {
            srcDir '../src/main/java'
        }
        resources {
            srcDir '../src/main/resources'
        }
    }
    test {
        java {
            srcDir '../src/test/java'
        }
        resources {
            srcDir '../src/test/resources'
        }
    }
}

task setupSourceSets {
	doLast {
		sourceSets {
			[api.java, api.resources, main.java, main.resources, test.java, test.resources]*.srcDirs*.mkdirs()
		}
	}
	[tasks.eclipse, tasks.idea]*.dependsOn 'setupSourceSets'
}

processResources {
	// this will ensure that this task is redone when the versions change.
	inputs.property 'version', project.version
	inputs.property 'mcversion', project.minecraft.version

	from(sourceSets.main.resources.srcDirs) {
		include 'mcmod.info'

		expand([
				'modid'		  : project.modid,
				'modname'		: project.modname,
				'version'		: mod_version,
				'mcversion'	  : project.version_minecraft,
				'forgeversion'   : project.version_forge,
				'minforgeversion': project.isProperty('version_minforge') ? project.version_minforge : project.version_forge,
		])
	}

	from(sourceSets.main.resources.srcDirs) {
		exclude 'mcmod.info'
	}
}

repositories {
	jcenter()
	maven {
		name = 'CurseForge'
		url = 'https://minecraft.curseforge.com/api/maven/'
	}
}

def projectName = "${rootProject.name}-${project.name}"

idea {
	module {
		name = projectName
	}
}

eclipse {
	project {
		name = projectName
	}
}

dependencies {
	compile fileTree(dir: 'libs', include: '*.jar')
	shade fileTree(dir: 'libs/shade', include: '*.jar')
	compile fileTree(dir: '../libs', include: '*.jar')
	shade fileTree(dir: '../libs/shade', include: '*.jar')
}

ext.commonManifest = {
	if (project.isProperty('extra_fmlcore'))
		attributes 'FMLCorePlugin': project.extra_fmlcore
	if (project.isProperty('extra_fmlmod'))
		attributes 'FMLCorePluginContainsFMLMod': project.extra_fmlcore
	if (project.isProperty('extra_fmlat'))
		attributes 'FMLAT': project.extra_fmlat
	attributes manifests.manifests
}

// println(shadowJar.getSource().getFiles())
shadowJar.configurations = [project.configurations.shade]

shadowJar {
	from sourceSets.main.output
	from sourceSets.api.output
	classifier 'universal'
	manifest commonManifest
}

jar {
	from sourceSets.main.output
	from sourceSets.api.output
	classifier 'diff'
	manifest commonManifest
}

println !reobf.hasProperty('dependsOn')
if (!reobf.hasProperty('dependsOn')) {
	reobf {
		shadowJar { mappingType = 'SEARGE' }
	}
} else {
	task reobfShadowJar (type: net.minecraftforge.gradle.tasks.user.reobf.ReobfTask) {
		dependsOn 'genSrgs'
		def fg_plugin = plugins.findPlugin project.forgegradle_plugin
		exceptorCfg = fg_plugin.delayedFile net.minecraftforge.gradle.user.UserConstants.EXC_SRG
		srg = fg_plugin.delayedFile net.minecraftforge.gradle.user.UserConstants.REOBF_SRG
		fieldCsv = fg_plugin.delayedFile net.minecraftforge.gradle.user.UserConstants.FIELD_CSV
		fieldCsv = fg_plugin.delayedFile net.minecraftforge.gradle.user.UserConstants.METHOD_CSV
		mcVersion = fg_plugin.delayedString '{MC_VERSION}'
		mustRunAfter 'test'
		mustRunAfter 'shadowJar'
		reobf.dependsOn 'reobfShadowJar'
		reobf(tasks.shadowJar) { arg ->
			def javaConv = project.convention.plugins.get 'java'
			arg.classpath = javaConv.getSourceSets().getByName('main').compileClasspath
		}
		extraSrg = fg_plugin.extension.srgExtra
		afterEvaluate {
			if (fg_plugin.extension.decomp) {
				deobfFile = tasks.deobfuscateJar.delayedOutput
				recompFile = fg_plugin.delayedDirtyFile fg_plugin.srcDepName, null, 'jar'
			}
		}
	}
	reobf.dependsOn 'reobfShadowJar'
}

if (tasks.findByPath('sourceJar')==null) {
	task sourceJar(dependsOn: 'classes', type: Jar) {
		from sourceSets.main.allSource
		classifier = 'sources'
		manifest commonManifest
	}
}

sourceJar {
	from sourceSets.api.allSource
}

// An Error occured while switching above 1.8 -> under 1.7
task cleanMakeStart(type: Delete) {
	makeStart.dependsOn 'cleanMakeStart'
	delete file(new File(tasks.makeStart.getTemporaryDir(), 'extracted'))
}

task devJar(dependsOn: 'classes', type: Jar) {
	from sourceSets.main.output
	from sourceSets.api.output
	classifier = 'dev'
	manifest commonManifest
}

task apiJar(dependsOn: 'classes', type: Jar) {
	from sourceSets.api.output
	classifier = 'api'
	manifest commonManifest
}

[jar, shadowJar, devJar, sourceJar, apiJar]*.destinationDir = mod_artifacts_dir

artifacts {
	archives jar
	archives shadowJar
	archives devJar
	archives sourceJar
	archives apiJar
}

task signJars(dependsOn: 'build') {
	if (project.isProperty('keystore_location')) {
		ext.keystore_location = project.keystore_location
		ext.keystore_alias = project.isProperty('keystore_alias') ? project.keystore_alias : ''
		ext.keystore_password = project.isProperty('keystore_password') ? project.keystore_password : ''

		inputs.dir shadowJar.destinationDir
		inputs.file keystore_location
		inputs.property 'keystore_alias', keystore_alias
		inputs.property 'keystore_password', keystore_password
		outputs.dir shadowJar.destinationDir

		doLast {
			[jar, shadowJar, devJar, sourceJar, apiJar].each { eachtask ->
				eachtask.outputs.files.each { file ->
					if (!file.path.endsWith('.jar'))
						return

					logger.lifecycle "signing ${file}"
					ant.signjar(
							destDir: file.parentFile,
							jar: file,
							keystore: keystore_location,
							alias: keystore_alias,
							storepass: keystore_password
					)
				}
			}
		}
	} else
		enabled = false
}

task deploy(dependsOn: 'build', type: Copy) {
	mustRunAfter 'signJars'

	deploy_target.targets.each { target ->
		def dest = target.name.endsWith('.jar') ? target.parentFile : target

		from(project.tasks.shadowJar.outputs.files.singleFile)
		into(dest)

		rename { String oldname ->
			target.name.endsWith('.jar') ? target.name : oldname
		}

		eachFile { file ->
			def path = file.relativePath.getFile(dest)
			logger.lifecycle "copying to ${path}"
		}
	}
}

def textChangelog = project.isProperty('extra_changelog') ? project.extra_changelog : ''
if (project.isProperty('extra_changelog_location')) {
	def fileChangelog = file('changelog.md')
	textChangelog = fileChangelog.exists()?fileChangelog.getText('UTF-8'):''
}
def pre = project.isProperty('version_qualifier')

tasks.curseforge.mustRunAfter 'signJars'
if (project.isProperty('api_key_curseforge') && project.isProperty('extra_curseforge_id')) {
	curseforge {
		tasks.curseforge.mustRunAfter 'signJars'
		apiKey = project.api_key_curseforge
		project {
			id = project.extra_curseforge_id

			changelogType = 'markdown'
			changelog = textChangelog

			def releasetype = 'alpha'
			if (pre) {
				if (project.version_qualifier=='beta')
					releasetype = 'beta'
			} else
				releasetype = 'release'
			releaseType = releasetype

			mainArtifact(shadowJar) {
				displayName = "${shadowJar.baseName}-${shadowJar.version}"
			}
			[jar, devJar, sourceJar, apiJar].each { jar ->
				addArtifact(jar) {
					displayName = "${jar.baseName}-${jar.version}-${jar.classifier}"
				}
			}

			relations {
			}
		}
	}
} else
	tasks.curseforge.enabled = false

tasks.githubRelease.mustRunAfter 'signJars'
if (project.isProperty('api_key_github') && project.isProperty('extra_github_owner') && project.isProperty('extra_github_repo')) {
	github {
		tasks.githubRelease.dependsOn 'build'
		prerelease = pre
		owner = project.extra_github_owner
		repo = project.extra_github_repo
		token = project.api_key_github
		tagName = shadowJar.version
		targetCommitish = plugins.findPlugin('com.palantir.git-version').gitRepo(rootProject).repository.getRef('HEAD').objectId.name()
		def title = (project.isProperty('extra_github_title')) ? project.release_title : shadowJar.version
		name = title.replace('{version}', shadowJar.version)
		body = textChangelog
		draft = false
		assets = [shadowJar, jar, devJar, sourceJar, apiJar]*.outputs*.files*.asPath*.tr('\\','/')
	}
} else
	tasks.githubRelease.enabled = false

['project.gradle'].each { def its = rootProject.file(it); if (its.exists()) apply from: its }
['project.gradle'].each { def its = file(it); if (its.exists()) apply from: its }