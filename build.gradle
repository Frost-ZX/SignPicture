buildscript {
}

allprojects {
	project.metaClass {
		isProperty = { propName ->
			return delegate.hasProperty(propName)&&!delegate.property(propName).empty
		}
	}
}

ext {
	(mod_buildnumber_file, mod_version, mod_buildnumber, mod_artifacts_dir) = ({
		assert project.isProperty('version_major'): 'missing property: version_major'
		assert project.isProperty('version_minor'): 'missing property: version_minor'
		assert project.isProperty('version_patch'): 'missing property: version_patch'
		def buildnumberfile = file 'buildnum.properties'
		def modversion = "${project.version_major}.${project.version_minor}.${project.version_patch}"
		def buildnumbermicro = 0
		if (project.isProperty('version_qualifier')) {
			def buildnumber = System.getenv 'TRAVIS_BUILD_NUMBER'

			def props = new Properties()
			if (buildnumberfile.exists())
				buildnumberfile.withInputStream { stream ->
					props.load stream
				}

			if (props.buildnumber &&
					props.version_major == project.version_major &&
					props.version_minor == project.version_minor &&
					props.version_patch == project.version_patch &&
					props.version_qualifier == project.version_qualifier)
				buildnumbermicro = props.buildnumber as Integer

			def buildtext = buildnumber ? '.'+buildnumber : ''
			def buildtextmicro = buildnumbermicro>0 ? '+'+String.format('%03d', buildnumbermicro) : ''
			modversion = "${modversion}-${project.version_qualifier}${buildtext}${buildtextmicro}"
		}
		def modartifactsdir = file "artifacts/${modversion}"
		[buildnumberfile, modversion, buildnumbermicro, modartifactsdir]
	})()
}

task increment {
	doLast {
		def props = new Properties()
		props.version_major = project.version_major
		props.version_minor = project.version_minor
		props.version_patch = project.version_patch
		props.version_qualifier = project.version_qualifier
		props.buildnumber = mod_buildnumber+1 as String
		mod_buildnumber_file.withOutputStream { stream ->
			props.store stream, 'Build Number Property'
		}
	}
}

class DeployExtension {
	def project, targets

	DeployExtension(proj, List tar) {
		targets = tar
		project = proj
	}

	DeployExtension(proj) {
		this(proj, [])
	}

	void target(File t) {
		targets.add(t)
	}

	void target(String t) {
		target(project.file(t))
	}
}

class ManifestExtension {
	def manifests

	ManifestExtension(def mf) {
		manifests = mf
	}

	ManifestExtension() {
		this([:])
	}

	void manifest(String key, String value) {
		targets.put(key, value)
	}

	void manifest(Map map) {
		targets.putAll(map)
	}
}

project.extensions.create('deploy', DeployExtension, project)
project.extensions.create('manifests', ManifestExtension)
['private.gradle', 'properties.gradle'].each { def its = file(it); if (its.exists()) apply from: its }

subprojects {
	ext.deploy_target = project.extensions.create('deploy', DeployExtension, project, deploy.targets.clone())
	ext.manifests = project.extensions.create('manifests', ManifestExtension, manifests.manifests.clone())
	['private.gradle', 'properties.gradle'].each { def its = file(it); if (its.exists()) apply from: its }

	afterEvaluate {
		tasks.build.dependsOn increment
	}
}

evaluationDependsOnChildren()

apply plugin: 'java'

version = "${mod_version}"

jar {
	subprojects.each { p ->
		if (p.name=='common') {
			manifest p.commonManifest
			p.tasks.shadowJar.outputs.files.each { f ->
				from zipTree(f)
			}
		} else {
			p.tasks.jar.outputs.files.each { f ->
				from(f) {
					rename '.*', p.name+'.jar'
				}
			}
		}
		dependsOn p.tasks.build
	}
	classifier = 'universal'
	destinationDir = mod_artifacts_dir
}